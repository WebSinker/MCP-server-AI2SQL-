// File: mysqlWorkbenchConnector.js
const fs = require('fs').promises;
const path = require('path');
const { execFile } = require('child_process');
const util = require('util');
const execFilePromise = util.promisify(execFile);

// Configuration - add these to your .env file
// MYSQL_WORKBENCH_PATH=path/to/mysql/workbench/executable
// SCRIPTS_DIRECTORY=path/to/store/sql/scripts

/**
 * Apply SQL query to MySQL Workbench
 * This function can work in two ways:
 * 1. Save the SQL to a script file that can be opened in MySQL Workbench
 * 2. Execute the SQL directly using MySQL Workbench CLI (if available)
 */
async function applyToMySQLWorkbench(sqlQuery, scriptName = null) {
  try {
    const timestamp = new Date().toISOString().replace(/[:.-]/g, '_');
    const fileName = scriptName || `sql_script_${timestamp}.sql`;
    
    // Get script directory from environment variable or use default
    const scriptsDir = process.env.SCRIPTS_DIRECTORY || path.join(__dirname, 'sql_scripts');
    
    // Ensure the scripts directory exists
    await fs.mkdir(scriptsDir, { recursive: true });
    
    // Full path to the script file
    const scriptPath = path.join(scriptsDir, fileName);
    
    // Check if the file exists
    let fileExists = false;
    try {
      await fs.access(scriptPath);
      fileExists = true;
    } catch (err) {
      // File doesn't exist, which is fine
    }
    
    if (fileExists) {
      // If file exists, read its content and append the new query
      const existingContent = await fs.readFile(scriptPath, 'utf8');
      
      // Add a separator and timestamp between queries
      const timestamp = new Date().toISOString();
      const separator = `\n\n-- New query added on ${timestamp} --\n\n`;
      
      // Append the new query to the existing content
      await fs.writeFile(scriptPath, existingContent + separator + sqlQuery, 'utf8');
    } else {
      // Create a header with metadata for new files
      const timestamp = new Date().toISOString();
      const header = `-- SQL Script: ${fileName}
-- Created: ${timestamp}
-- Generated by Natural Language to SQL Converter
-- Description: This file contains SQL queries generated from natural language inputs.

`;
      // Write the SQL query with the header to a new file
      await fs.writeFile(scriptPath, header + sqlQuery, 'utf8');
    }
    
    // Attempt to execute the script directly if MySQL Workbench path is provided
    const workbenchPath = process.env.MYSQL_WORKBENCH_PATH;
    
    if (workbenchPath) {
      try {
        // Connection parameters - can be extended to use environment variables
        const dbUser = process.env.DB_USER || 'root';
        const dbPassword = process.env.DB_PASSWORD || 'your_password';
        const dbHost = process.env.DB_HOST || 'localhost';
        const dbPort = process.env.DB_PORT || '3306';
        const dbName = process.env.DB_NAME || 'your_database';
        
        // Execute the script using MySQL client (not Workbench) for direct execution
        // Note: mysql command line client is more suitable for direct execution than Workbench
        const mysqlCliPath = process.env.MYSQL_CLI_PATH || 'mysql';
        
        const result = await execFilePromise(mysqlCliPath, [
          `-u${dbUser}`,
          `-p${dbPassword}`,
          `-h${dbHost}`,
          `-P${dbPort}`,
          dbName,
          '-e',
          `source ${scriptPath}`
        ]);
        
        return {
          method: 'direct_execution',
          scriptPath,
          output: result.stdout,
          error: result.stderr
        };
      } catch (execError) {
        console.warn('Direct execution failed:', execError.message);
        // Fall back to just saving the script if execution fails
      }
    }
    
    // If we couldn't execute directly, just return the script path
    return {
      method: 'script_saved',
      scriptPath,
      fileAction: fileExists ? 'appended' : 'created',
      message: fileExists 
        ? 'SQL query appended to existing script. You can open it in MySQL Workbench manually.' 
        : 'New SQL script created. You can open it in MySQL Workbench manually.',
      openCommand: `${workbenchPath ? workbenchPath : 'mysqlworkbench'} "${scriptPath}"`
    };
  } catch (error) {
    console.error('Error in MySQL Workbench connector:', error);
    throw new Error(`Failed to apply SQL to MySQL Workbench: ${error.message}`);
  }
}

module.exports = {
  applyToMySQLWorkbench
};